---
layout: post
title: "Head First : Design Patterns  读书笔记"
description: "1.找出应用中可能变化的部分，把他们独立出来，不要和那些不需要变化的代码混在一起。
另一种思考方式：把会变化的部分取出并封装起来，以便以后可以轻易地改动或扩充此部分，而不影响不需要变化的其他部分。"
categories: 技术 java 设计模式
tags: [设计模式]
---
{% include JB/setup %}


### 设计原则：   

1.找出应用中可能变化的部分，把他们独立出来，不要和那些不需要变化的代码混在一起。
另一种思考方式：把会变化的部分取出并封装起来，以便以后可以轻易地改动或扩充此部分，而不影响不需要变化的其他部分。

2.针对接口编程，而不是针对实现编程。
“针对接口编程”真正的意思是“针对超类型（supertype）编程”。

3.多用组合（composition），少用继承

4.为了交互对象之间的松耦合设计而努力

5.类应该对扩展开放，对修改关闭

6.依赖倒置原则（Dependency Inversion Principle）：要依赖抽象，不要依赖具体类
	1)变量不可以持有具体类的引用
	2)不要让派生自具体类
	3)不要覆盖基类中已实现的方法
7.最少知识原则（Least Knowledge）：只和你的密友交谈。
	我们只应该调用以下范围内的方法：
	1）该对象本身
	2）被当做方法的参数而传递进来的对象
	3）此方法创建或实例化的任何对象
	4）对象的任何组件   
	
得墨忒耳定律（Law of Demeter，缩写LoD）也叫做“最少知识原则”，是一种开发软件的设计原理，特别是面向对象的程序设计，得墨忒耳定律是松耦合的一种特殊情况。该指导原则是1987年末在美国东北大学发明的，该原则可以简单地概括为以下方式之一：
每个单元对于其他的单元只能拥有有限的知识：只是与当前单元紧密联系的单元；
每个单元只能和它的朋友交谈：不能和陌生单元交谈；
只和自己直接的朋友交谈。
这个原理的名称来源于希腊神话中的农业女神，孤独的得墨忒耳。

8.好莱坞原则：别调用（打电话给）我们，我们会调用（打电话给）你。

9.一个类应该只有一个引起变化的原因 。


### 模式简单定义：   

1.策略模式：定义算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

2.观察者模式：在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知，并自动更新。

3.装饰者模式：动态地将责任附加到对象上。想要扩展功能，装饰者提供有别于继承的另一种选择。

4.抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

5.工厂方法模式：定义了一个创建对象的接口，但有子类决定要实例化的类是哪一个。工厂方法把类的实例化推迟到子类。

6.单例模式：确保一个类只有一个实例，并提供全局访问点。

7.命令模式：将请求封装成对象，这可以让你使用不同的请求、队列或者日志请求来参数化其他对象。命令模式也可以支持撤销操作。当需要将发出请求的对象和执行请求的对象解耦的时候，使用命令模式。

8.适配器模式：将一个类的接口转换成客户期望的接口，适配器让原本不兼容的类可以合作无间。

9.外观模式：提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

10.模板方法模式：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的前提下，重新定义算法中的某些步骤。

装饰者、适配器、外观的区别：
装饰者：不改变接口，但假如责任
适配器：将一个接口转换成另一个接口
外观：让接口更简单

11.迭代器模式：提供一种方法顺序访问一个聚合对象内的各个元素，而又不暴露其内部的表示。

12.组合模式：允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。

13.命令模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。

14.代理模式：为另一个对象提供一个替身或占位符以控制对这个对象的访问。
